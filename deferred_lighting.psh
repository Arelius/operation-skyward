// Copyright (c) 2010, Nicholas "Indy" Ray. All rights reserved.
// See the LICENSE file for usage, modification, and distribution terms.

uniform sampler2D color_buffer;
uniform sampler2D normal_buffer;
uniform sampler2D ambient_buffer;
uniform sampler2D specular_buffer;
uniform sampler2D emissive_buffer;

uniform vec3 directional_light;
uniform mat4 inv_projection;

float roughness = 0.1;
float PI = 3.14159265;

vec4 unproject(vec4 x)
{
    return x * inv_projection;
}

void main(void)
{
    //float dot = abs(dot(texture2D(normal_buffer, gl_TexCoord[0].xy).xyz, directional_light));
    //gl_FragColor = texture2D(color_buffer, gl_TexCoord[0].xy);
    //gl_FragColor = vec4(dot, dot, dot, dot);
    //gl_FragColor = texture2D(normal_buffer, gl_TexCoord[0].xy);
    //gl_FragColor = texture2D(emissive_buffer, gl_TexCoord[0].xy);
    //gl_FragColor = vec4(directional_light, 1.0);

    vec3 diffuse = texture2D(color_buffer, gl_TexCoord[0].xy).xyz;
    // This math is BAD!
    vec3 normal = normalize(vec3(texture2D(normal_buffer, gl_TexCoord[0].xy).xy, 1.0));
    vec3 light = normalize(directional_light);
    vec3 location =
        normalize(
            unproject(
                vec4(
                    gl_TexCoord[0].xy,
                    texture2D(normal_buffer, gl_TexCoord[0].xy).w,
                    1.0)).xyz);

    float alpha =
        max(acos(dot(location, normal)),
            acos(dot(light, normal)));

    float beta =
        min(acos(dot(location, normal)),
            acos(dot(light, normal)));

    float gamma =
        dot(location - normal * dot(location, normal),
            light - normal * dot(light, normal));

    float roughness_sq = roughness * roughness;

    float C1 = 1.0 - 0.5 * (roughness_sq / (roughness_sq + 0.33));
    float C2 = 0.45 * (roughness_sq / (roughness_sq + 0.09));

    if(gamma >= 0.0)
        C2 *= sin(alpha);
    else
        C2 *= sin(alpha) - pow((2.0 * beta)/PI, 3.0);

    float C3 = 1.0 / 8.0;

    C3 *= roughness_sq / (roughness_sq + 0.09);
    C3 *= pow((4.0 * alpha * beta) / (PI * PI), 2.0);

    float A = gamma * C2 * tan(beta);
    float B = (1.0 - abs(gamma)) * C3 * tan((alpha + beta) / 2.0);

    vec3 color = diffuse * max(0.0, dot(normal, light)) * (C1 + A + B);
    float C = texture2D(normal_buffer, gl_TexCoord[0].xy).w;
    //color = vec3(C, C, C);
    //color = normal;
    gl_FragColor = vec4(color, 1.0);
}
